import MJS from 'MJS/mjs';

var Rule = function(params) {
  _.assign(this, {
    type: Rule.Type.EVOLVE,
    // symbols consumed by the rule
    reactants: {},
    // symbols generated by the rule
    products: {},
    charge: null,
    label: null
  }, params);

  if (typeof this.type === 'undefined')
    throw 'Unsupported Rule Type('+this.type+')';
};

Rule.prototype.clone = function() {
  return new Rule({
    type: this.type,
    reactants: _.cloneDeep(this.reactants),
    products: _.cloneDeep(this.products),
    charge: this.charge,
    label: this.label
  });
};
Rule.prototype.numberApplications = function(world) {
  var self = this,
      num = 0,
      tempWorld = _.cloneDeep(world),
      applied;
  do {
    applied = this.applyRule(tempWorld);
    if (applied) {
      num+=1;
    }
  } while(applied);
  return num;
};
/**
 * Apply the rule to the given world. Only updates the world
 * if it can actually apply the rule
 * @param  {object} oldWorld {symbol:count,...} world to decrement but not add to
 * @param  {object} world {symbol:count,...} (optional) world to both decrement and add to
 * @return {bool/object} Whether the rule was applied or not, or world set object if sending out
 */
Rule.prototype.applyRule = function(oldWorld, world) {
  var self = this,
      applied = true,
      sendOutSet = {};

  // First preprocess to check if all rules can apply
  _.forEach(self.reactants, function(count, symbol) {
    if (typeof oldWorld[symbol] === 'undefined' || oldWorld[symbol] < count) {
      applied = false;
      return false;
    }
  });

  // Then apply them all if possible
  if (applied) {
    _.forEach(self.reactants, function(count, symbol) {
      oldWorld[symbol]-= count;
      if (world)
        world[symbol]-= count;
    });

    if (world)
      MJS.log('apply rule: '+this.toString());

    _.forEach(self.products, function(count, symbol) {
      var w = world;
      if (self.type === Rule.Type.SEND_OUT ||
          self.type === Rule.Type.DISSOLVE)
      {
        w = sendOutSet;
      }

      if (w && typeof w[symbol] === 'undefined')
        w[symbol] = 0;
      if (w)
        w[symbol]+=count;
    });
  }

  if (_.keys(sendOutSet).length) {
    return sendOutSet;
  }
  return applied;
};
Rule.prototype.toString = function() {
  return "Rule("+this.type+") react"+MJS.setToString(this.reactants)+' prod'+MJS.setToString(this.products);
};

Rule.Type = {
  EVOLVE: 'evolve',
  SEND_OUT: 'sendOut',
  DISSOLVE: 'dissolve',
  // TODO other rule types
  //SEND_IN: 'sendIn',
  //ELEMENTARY_DIVISION: 'elementaryDivision',
  //NONELEMENTARY_DIVIONS: 'nonelementaryDivision'
};

MJS.Rule = Rule;
export default Rule;
